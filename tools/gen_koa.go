package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
)

//GenKoa record go code information.
type GenKoa struct {
	code     bytes.Buffer
	vc       int      // var count. Used to generate unique variable names
	I        []string // imports with path
	path     string
	prefix   string
	tarsPath string
	p        *Parse
}

func (gen *GenKoa) genErr(err string) {
	panic(err)
}

func (gen *GenKoa) saveToSourceFile(filename string) {
	var beauty []byte
	var err error
	prefix := gen.prefix

	if !*gE {
		beauty, err = format.Source(gen.code.Bytes())
		if err != nil {
			gen.genErr("go fmt fail. " + err.Error())
		}
	} else {
		beauty = gen.code.Bytes()
	}

	if filename == "stdout" {
		fmt.Println(string(beauty))
	} else {
		err = os.MkdirAll(prefix+gen.p.Module, 0766)

		if err != nil {
			gen.genErr(err.Error())
		}
		err = ioutil.WriteFile(prefix+gen.p.Module+"/"+filename, beauty, 0666)

		if err != nil {
			gen.genErr(err.Error())
		}
	}
}

func (gen *GenKoa) genHead() {
	gen.code.WriteString(`//Package ` + gen.p.Module + ` comment
// This file war generated by tars2koa ` + VERSION + `
// Generated from ` + filepath.Base(gen.path) + `
`)
}

func (gen *GenKoa) genLife() {
	gen.code.Reset()
	gen.genHead()
	gen.code.WriteString("\n\"use strict\";\n\n")
	gen.code.WriteString(`
const life = require('koa-router')();
	
life.get('/info', async (ctx, next) => {
	ctx.set('Content-Type', 'application/json');
	ctx.body = {};
});
	  
life.get('/health', async (ctx, next) => {
	ctx.set('Content-Type', 'application/json');
	ctx.body = {status: 'UP'};
});

module.exports = life
	`)
	gen.saveToSourceFile("life.js")
}

func (gen *GenKoa) genRouter() {
	gen.code.Reset()
	gen.genHead()
	c := &gen.code
	c.WriteString("\n\"use strict\";\n\n")
	c.WriteString("var Stream = require('@tars/stream');")
	c.WriteString("var Client = require('@tars/rpc').client;\n")
	c.WriteString("var " + gen.p.Module + " = require('./" + gen.p.Source + "Proxy')." + gen.p.Module + ";\n")
	c.WriteString("const router = require('koa-router')();\n")
	for _, v := range gen.p.Interface {
		c.WriteString("var prx_" + v.TName + " = Client.stringToProxy(" + gen.p.Module + "." + v.TName + "Proxy, ")
		c.WriteString("router.post('/'" + v.TName + ", async (ctx, next) => {\n")
		c.WriteString("\t" + "try {\n")
		c.WriteString("\t\t" + "var tup_decode = new Stream.Tup();\n")
		c.WriteString("\t\t" + "tup_decode.decode(new Tars.BinBuffer(ctx.request.body));\n")
		c.WriteString("\t" + "} catch (err) {\n")
		c.WriteString("\t\t" + "console.log('error:' + err);\n")
		c.WriteString("\t\t" + "ctx.response.status = 500;\n")
		c.WriteString("\t\t" + "ctx.response.body = '';\n")
		c.WriteString("\t" + "}")
		c.WriteString("});\n")
	}
	c.WriteString(`module.exports = router`)
	gen.saveToSourceFile("router.js")
}

func (gen *GenKoa) genEureka() {
	gen.code.Reset()
	gen.code.WriteString(`
eureka:
  host: #eureka ip
  port: #eureka port
  servicePath: '/eureka/apps/'

instance:
  app: #app name
  ipAddr: #running ip
  port:
    '$': #running port
	'@enabled': 'true'
  hostName: #$(instance.ipAddr):$(instance.port.$)
  statusPageUrl: #http://$(instance.hostName)/info
  healthCheckUrl: #http://$(instance.hostName)/health
  vipAddress: 'vip'
  dataCenterInfo:
    '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo'
    name: 'MyOwn'
	`)
	gen.saveToSourceFile("eureka.yml")
}

func (gen *GenKoa) genKoa() {
	gen.code.Reset()
	gen.genHead()
	gen.code.WriteString("\n\"use strict\";\n\n")
	gen.code.WriteString(`
const Eureka = require('eureka-js-client').Eureka;
const client = new Eureka({
	filename: 'eureka',
	cwd: '${__dirname}',
});
	`)
	gen.code.WriteString(`
const app = require('koa')();
const life = require('life');
const router = require('router');

app.use(life.routes(), life.allowedMethods());
app.use(router.routes(), router.allowedMethods());

client.start(err => {
	app.listen(process.env.PORT || 3000, () => {
		console.log('server is running');
	});
});
	`)
	gen.saveToSourceFile("registry.js")
}

func (gen *GenKoa) genAll() {

	gen.genEureka()

	gen.genLife()

	gen.genRouter()

	gen.genKoa()
}

//Gen to parse file.
func (gen *GenKoa) Gen() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(err)
			// set exit code
			os.Exit(1)
		}
	}()

	gen.p = ParseFile(gen.path)
	gen.genAll()
}

//NewGenKoa build up a new path
func NewGenKoa(path string, outdir string) *GenKoa {
	if outdir != "" {
		b := []byte(outdir)
		last := b[len(b)-1:]
		if string(last) != "/" {
			outdir += "/"
		}
	}

	return &GenKoa{path: path, prefix: outdir}
}
